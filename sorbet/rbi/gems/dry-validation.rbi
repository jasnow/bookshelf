# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dry-validation/all/dry-validation.rbi
#
# dry-validation-0.11.0
module Dry
end
module Dry::Validation
  def self.Form(base = nil, **options, &block); end
  def self.JSON(base = nil, **options, &block); end
  def self.Schema(base = nil, **options, &block); end
  def self.messages_paths; end
  extend Dry::Core::Extensions
  include Dry::Core::Constants
end
class Dry::Validation::PredicateRegistry
  def [](name); end
  def arg_list(name, *values); end
  def ensure_valid_predicate(name, args_or_arity, schema = nil); end
  def external; end
  def initialize(external, predicates = nil); end
  def key?(name); end
  def new(klass); end
  def predicates; end
  def raise_invalid_arity_error(name); end
  def raise_unknown_predicate_error(name); end
  def self.[](klass, predicates); end
end
class Dry::Validation::PredicateRegistry::Bound < Dry::Validation::PredicateRegistry
  def initialize(*args); end
  def schema; end
end
class Dry::Validation::PredicateRegistry::Unbound < Dry::Validation::PredicateRegistry
  def bind(schema); end
  def update(other); end
end
class Dry::Validation::Guard
  def call(input, results); end
  def deps; end
  def deps_valid?(results); end
  def initialize(rule, deps); end
  def rule; end
  def with(options); end
end
class Dry::Validation::SchemaCompiler < Dry::Logic::RuleCompiler
  def initialize(*args, options); end
  def options; end
  def schema; end
  def visit_custom(node); end
  def visit_guard(node); end
  def visit_predicate(node); end
  def visit_rule(node); end
  def visit_schema(klass); end
  def visit_type(type); end
end
module Dry::Validation::Deprecations
  def logger; end
  def self.format(msg, caller); end
  def warn(msg); end
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
end
class Dry::Validation::Schema
  def arity; end
  def ast(*arg0); end
  def call(input); end
  def checks; end
  def config; end
  def curry(*curry_args); end
  def executor; end
  def initialize(rules, options); end
  def initialize_checks(checks); end
  def initialize_options(options); end
  def initialize_rules(rules); end
  def input_processor; end
  def input_rule; end
  def message_compiler; end
  def options; end
  def predicates; end
  def rule_compiler; end
  def rules; end
  def self.clone; end
  def self.create_class(target, other = nil, &block); end
  def self.default_messages; end
  def self.default_options; end
  def self.define!(options = nil, &block); end
  def self.define(options = nil, &block); end
  def self.inherited(klass); end
  def self.input_processor; end
  def self.input_processor_ast(type); end
  def self.input_processor_compiler; end
  def self.message_compiler; end
  def self.messages; end
  def self.new(rules = nil, **options); end
  def self.option(name, default = nil); end
  def self.options; end
  def self.predicates(predicate_set = nil); end
  def self.registry; end
  def self.rule_ast; end
  def self.rules; end
  def self.set_registry!; end
  def self.to_ast; end
  def self.type_map; end
  def to_ast(*arg0); end
  def to_proc; end
  def type_map; end
  def with(new_options); end
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  extend Dry::Validation::TypeSpecs
end
class Dry::Validation::Schema::Rule < BasicObject
  def &(other); end
  def >(other); end
  def ^(other); end
  def add_rule(rule); end
  def and(other); end
  def checks; end
  def class; end
  def deps; end
  def each(*predicates, &block); end
  def filled(*predicates, &block); end
  def infer_predicates(predicates, macro = nil); end
  def initialize(node, options = nil); end
  def inspect; end
  def key(predicate, args = nil); end
  def maybe(*predicates, &block); end
  def method_missing(meth, *args, &block); end
  def name; end
  def new(node); end
  def node; end
  def not; end
  def options; end
  def or(other); end
  def registry; end
  def required(*predicates); end
  def rule_ast; end
  def rules; end
  def schema(other = nil, &block); end
  def schema?; end
  def target; end
  def then(other); end
  def to_ast; end
  def to_rule; end
  def to_s; end
  def type; end
  def type_map; end
  def type_map?; end
  def value(*predicates, &block); end
  def with(new_options); end
  def xor(other); end
  def |(other); end
  include Dry::Validation::Deprecations
end
class Dry::Validation::Schema::DSL < BasicObject
  def add_check(check); end
  def add_rule(rule); end
  def checks; end
  def create_rule(node, name = nil); end
  def define(name, key_class, op = nil, &block); end
  def initialize(options = nil); end
  def inspect; end
  def name; end
  def not; end
  def optional(name, type_spec = nil, &block); end
  def options; end
  def parent; end
  def path; end
  def predicate(name, args = nil); end
  def predicate?(meth); end
  def registry; end
  def rule_ast; end
  def rules; end
  def self.[](name, options = nil); end
  def to_ast; end
  def to_rule; end
  def to_s; end
  def with(new_options); end
  include Dry::Validation::Deprecations
end
class Dry::Validation::Schema::Key < Dry::Validation::Schema::DSL
  def class; end
  def each(*predicates, &block); end
  def hash?(&block); end
  def method_missing(meth, *args, &block); end
  def parent; end
  def schema(other = nil, &block); end
  def self.type; end
  def to_ast; end
  def type; end
  def value; end
end
class Dry::Validation::Schema::Value < Dry::Validation::Schema::DSL
  def check(name, options = nil); end
  def class; end
  def configure(&block); end
  def confirmation; end
  def dyn_arg?(name); end
  def each(*predicates, &block); end
  def infer_predicates(predicates, infer_on = nil); end
  def initialize(options = nil); end
  def input(*predicates); end
  def key(name, &block); end
  def key?(name); end
  def method_missing(meth, *args, &block); end
  def new; end
  def node(input, *args); end
  def predicates(mod); end
  def required(name, type_spec = nil, &block); end
  def respond_to?(name); end
  def root?; end
  def rule(id = nil, **options, &block); end
  def schema(other = nil, &block); end
  def schema?; end
  def schema_class; end
  def type; end
  def type_map; end
  def type_map?; end
  def validate(**opts, &block); end
  def value(path, opts = nil); end
  def when(*predicates, &block); end
end
class Dry::Validation::Schema::Check < Dry::Validation::Schema::Value
  def class; end
  def method_missing(meth, *meth_args); end
  def schema(other = nil, &block); end
end
class Dry::Validation::Result
  def [](name); end
  def ast(*arg0); end
  def each(&block); end
  def errors(options = nil); end
  def failure?; end
  def hints(options = nil); end
  def initialize(output, results, message_compiler, path); end
  def message_compiler; end
  def message_set(options = nil); end
  def messages(options = nil); end
  def name; end
  def output; end
  def path; end
  def result_ast; end
  def results; end
  def success?; end
  def to_ast; end
  def to_h; end
  def to_hash; end
  def type; end
  include Anonymous_Dry_Equalizer_18
  include Dry::Equalizer::Methods
  include Enumerable
end
module Anonymous_Dry_Equalizer_18
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Dry::Validation::Messages
  def self.default; end
end
class Dry::Validation::Messages::Abstract
  def [](*args); end
  def cache; end
  def call(*args); end
  def config; end
  def default_locale; end
  def hash; end
  def initialize; end
  def lookup(predicate, options = nil); end
  def lookup_paths(tokens); end
  def namespaced(namespace); end
  def root; end
  def rule(name, options = nil); end
  def self.cache; end
  extend Dry::Configurable
  extend Dry::Configurable::ClassMethods
  include Anonymous_Dry_Equalizer_19
  include Dry::Equalizer::Methods
end
module Anonymous_Dry_Equalizer_19
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Validation::Messages::Namespaced < Dry::Validation::Messages::Abstract
  def default_locale; end
  def get(key, options = nil); end
  def initialize(namespace, messages); end
  def key?(key, *args); end
  def lookup_paths(tokens); end
  def messages; end
  def namespace; end
  def root; end
end
class Dry::Validation::Messages::YAML < Dry::Validation::Messages::Abstract
  def data; end
  def get(key, options = nil); end
  def initialize(data); end
  def key?(key, options = nil); end
  def merge(overrides); end
  def self.flat_hash(h, f = nil, g = nil); end
  def self.load(paths = nil); end
  def self.load_file(path); end
  include Anonymous_Dry_Equalizer_20
  include Dry::Equalizer::Methods
end
module Anonymous_Dry_Equalizer_20
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Validation::Message
  def args; end
  def eql?(other); end
  def hint?; end
  def initialize(predicate, path, text, options); end
  def options; end
  def path; end
  def predicate; end
  def root?; end
  def rule; end
  def self.[](predicate, path, text, options); end
  def signature; end
  def text; end
  def to_s; end
  include Anonymous_Dry_Equalizer_21
  include Dry::Equalizer::Methods
end
module Anonymous_Dry_Equalizer_21
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Dry::Validation::Message::Or
  def hint?; end
  def initialize(left, right, messages); end
  def left; end
  def messages; end
  def path; end
  def right; end
  def root?; end
  def to_s; end
end
class Dry::Validation::Message::Check < Dry::Validation::Message
  def initialize(*args); end
end
class Dry::Validation::Hint < Dry::Validation::Message
  def hint?; end
  def self.[](predicate, path, text, options); end
end
class Dry::Validation::MessageSet
  def dump; end
  def each(&block); end
  def empty?; end
  def failures; end
  def failures?; end
  def hint_groups; end
  def hints; end
  def hints_map; end
  def initialize(messages, options = nil); end
  def initialize_hints!; end
  def initialize_placeholders!; end
  def messages; end
  def messages_map; end
  def options; end
  def paths; end
  def placeholders; end
  def root?; end
  def self.[](messages, options = nil); end
  def to_a; end
  def to_h; end
  def to_hash; end
  include Enumerable
end
class Dry::Validation::MessageCompiler
  def call(ast); end
  def default_lookup_options; end
  def full?; end
  def hints?; end
  def initialize(messages, options = nil); end
  def locale; end
  def lookup_options(arg_vals: nil, input: nil); end
  def message_text(rule, template, tokens, opts); end
  def message_tokens(args); end
  def messages; end
  def options; end
  def visit(node, *args); end
  def visit_and(node, opts = nil); end
  def visit_check(node, opts = nil); end
  def visit_each(node, opts = nil); end
  def visit_failure(node, opts = nil); end
  def visit_hint(node, opts = nil); end
  def visit_implication(node, *args); end
  def visit_key(node, opts = nil); end
  def visit_not(node, opts = nil); end
  def visit_or(node, opts = nil); end
  def visit_predicate(node, base_opts = nil); end
  def visit_rule(node, opts = nil); end
  def visit_schema(node, opts = nil); end
  def visit_set(node, opts = nil); end
  def visit_type(node, opts = nil); end
  def visit_xor(node, opts = nil); end
  def with(new_options); end
end
class Dry::Validation::MessageCompiler::VisitorOpts < Hash
  def call(other); end
  def path; end
  def path?; end
  def rule; end
  def self.new; end
  def with_rule(new_rule, **other); end
end
class Dry::Validation::InputProcessorCompiler::Sanitizer < Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end
class Dry::Validation::InputProcessorCompiler::JSON < Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end
class Dry::Validation::InputProcessorCompiler::Form < Dry::Validation::InputProcessorCompiler
  def array_node(members); end
  def hash_node(schema); end
  def identifier; end
end
class Dry::Validation::InputProcessorCompiler
  def call(ast); end
  def constructor(type); end
  def initialize; end
  def schema_ast(ast); end
  def type(predicate, args); end
  def type_compiler; end
  def visit(node, *args); end
  def visit_and(node, first = nil); end
  def visit_each(node, *args); end
  def visit_implication(node, *args); end
  def visit_key(node, *args); end
  def visit_not(node, *args); end
  def visit_or(node, *args); end
  def visit_predicate(node, *arg1); end
  def visit_rule(node, *args); end
  def visit_schema(schema, *args); end
  def visit_set(node, *arg1); end
  def visit_type(type, *args); end
  def visit_val(node, *args); end
end
module Dry::Validation::TypeSpecs
  def build_array_type(spec, category); end
  def build_hash_type(spec = nil); end
  def build_sum_type(spec, category); end
  def build_type_map(type_specs, category = nil); end
  def lookup_type(name, category); end
  def resolve_spec(spec, category); end
  def self.extended(klass); end
end
class Dry::Validation::ProcessInput
  def call(input, *arg1); end
  def initialize(processor); end
  def processor; end
end
class Dry::Validation::ApplyInputRule
  def call(input, result); end
  def initialize(rule); end
  def rule; end
end
class Dry::Validation::ApplyRules
  def call(input, result); end
  def initialize(rules); end
  def rules; end
end
class Dry::Validation::ApplyChecks < Dry::Validation::ApplyRules
  def call(input, result); end
end
class Dry::Validation::BuildErrors
  def call(result); end
end
class Dry::Validation::Executor
  def call(input, result = nil); end
  def final; end
  def initialize(final); end
  def self.new(&block); end
  def steps; end
end
class Dry::Validation::Schema::Form < Dry::Validation::Schema
  def self.configure(klass = nil, &block); end
  def self.method_added(name); end
end
class Dry::Validation::Schema::JSON < Dry::Validation::Schema
  def self.configure(klass = nil, &block); end
  def self.method_added(name); end
end
class Dry::Validation::MissingMessageError < StandardError
end
class Dry::Validation::InvalidSchemaError < StandardError
end

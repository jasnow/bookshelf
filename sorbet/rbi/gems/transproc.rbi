# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/transproc/all/transproc.rbi
#
# transproc-1.1.0
module Transproc
end
class Transproc::Composite
  def +(other); end
  def >>(other); end
  def [](value); end
  def call(value); end
  def compose(other); end
  def initialize(left, right); end
  def left; end
  def right; end
  def to_ast; end
end
class Transproc::Function
  def +(other); end
  def ==(other); end
  def >>(other); end
  def [](*value); end
  def args; end
  def call(*value); end
  def compose(other); end
  def eql?(other); end
  def fn; end
  def initialize(fn, options = nil); end
  def name; end
  def to_ast; end
  def to_proc; end
  def with(*args); end
end
module Transproc::Functions
  def method_added(meth); end
  def self.extended(mod); end
end
module Transproc::Deprecations
  def self.announce(name, msg); end
end
module Transproc::Composer
  def compose(default = nil); end
end
class Transproc::Composer::Factory
  def <<(other); end
  def default; end
  def fns; end
  def initialize(default = nil); end
  def t(*args, &block); end
  def to_fn; end
end
class Transproc::Error < StandardError
end
class Transproc::FunctionAlreadyRegisteredError < Transproc::Error
end
class Transproc::FunctionNotFoundError < Transproc::Error
  def initialize(function, source = nil); end
end
class Transproc::Store
  def contain?(key); end
  def fetch(key); end
  def import(*args); end
  def import_all(source); end
  def import_method(source, name, new_name = nil); end
  def import_methods(source, names); end
  def initialize(methods = nil); end
  def methods; end
  def register(name, fn = nil, &block); end
end
module Transproc::Registry
  def [](fn, *args); end
  def already_wrapped?(func); end
  def contain?(key); end
  def fetch(fn); end
  def import(*args); end
  def register(name, fn = nil, &block); end
  def store; end
  def t(fn, *args); end
  def uses(*args); end
end
class Transproc::Compiler
  def call(ast); end
  def initialize(registry, transformer = nil); end
  def registry; end
  def transformer; end
  def visit(node); end
  def visit_arg(arg); end
  def visit_fn(node); end
  def visit_t(node); end
end
class Transproc::Compiler::InvalidFunctionNameError < StandardError
end
class Transproc::Transformer
  def call(input); end
  def transproc; end
  extend Transproc::Transformer::ClassInterface
  extend Transproc::Transformer::Deprecated::ClassInterface
end
class Transproc::Transformer::DSL
  def ast; end
  def call(transformer); end
  def container; end
  def dup; end
  def initialize(container, ast: nil, &block); end
  def method_missing(meth, *args, &block); end
  def node(&block); end
  def respond_to_missing?(method, _include_private = nil); end
end
module Transproc::Transformer::ClassInterface
  def [](container); end
  def container(container = nil); end
  def define!(&block); end
  def dsl; end
  def import(*args); end
  def inherited(subclass); end
  def new(*args); end
  def t(fn, *args); end
end
module Transproc::Transformer::Deprecated
end
module Transproc::Transformer::Deprecated::ClassInterface
  def build(&block); end
  def define(&block); end
  def inherited(subclass); end
  def method_missing(method, *args, &block); end
  def new(*args); end
  def respond_to_missing?(method, _include_private = nil); end
  def transformations; end
  def transproc; end
end
module Transproc::Coercions
  def self.identity(value = nil); end
  def self.to_boolean(value); end
  def self.to_date(value); end
  def self.to_datetime(value); end
  def self.to_decimal(value); end
  def self.to_float(value); end
  def self.to_integer(value); end
  def self.to_string(value); end
  def self.to_symbol(value); end
  def self.to_time(value); end
  def self.to_tuples(value); end
  extend Transproc::Registry
end
module Transproc::HashTransformations
  def self.accept_keys(hash, keys); end
  def self.copy_keys(source_hash, mapping); end
  def self.deep_merge(hash, other); end
  def self.deep_stringify_keys(hash); end
  def self.deep_symbolize_keys(hash); end
  def self.eval_values(hash, args, filters = nil); end
  def self.fold(hash, key, tuple_key); end
  def self.map_keys(source_hash, fn); end
  def self.map_value(hash, key, fn); end
  def self.map_values(source_hash, fn); end
  def self.nest(hash, root, keys); end
  def self.reject_keys(hash, keys); end
  def self.rename_keys(source_hash, mapping); end
  def self.split(hash, key, keys); end
  def self.stringify_keys(hash); end
  def self.symbolize_keys(hash); end
  def self.unwrap(source_hash, root, selected = nil, prefix: nil); end
  extend Transproc::Registry
end
module Transproc::ArrayTransformations
  def self.add_keys(array, keys); end
  def self.combine(array, mappings); end
  def self.extract_key(array, key); end
  def self.group(array, key, keys); end
  def self.insert_key(array, key); end
  def self.map_array(array, fn); end
  def self.ungroup(array, key, keys); end
  def self.wrap(array, key, keys); end
  extend Transproc::Registry
end
class Transproc::ArrayTransformations::Combine
  def self.add_groups_to_element(element, groups, mappings); end
  def self.combine(array, mappings); end
  def self.element_candidates(element, candidates, keys); end
  def self.element_candidates_key(element, keys); end
  def self.group_candidates(candidates, mapping); end
  def self.group_candidates_by_keys(candidates, keys); end
  def self.group_nodes(nodes, mappings); end
end
module Transproc::ClassTransformations
  def self.constructor_inject(*args, klass); end
  def self.set_ivars(ivar_hash, klass); end
  extend Transproc::Registry
end
module Transproc::Conditional
  def self.guard(value, predicate, fn); end
  def self.is(value, type, fn); end
  def self.not(value, fn); end
  extend Transproc::Registry
end
module Transproc::ProcTransformations
  def self.bind(value, binding, fn); end
  extend Transproc::Registry
end
module Transproc::Recursion
  def self.array_recursion(value, fn); end
  def self.hash_recursion(value, fn); end
  def self.recursion(value, fn); end
  extend Transproc::Registry
end
